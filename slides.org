#+TITLE: Functional Programming: Whys and Whats

* About Me:

  - John Soo
  - Developer, American Airlines Team
  - Your local functional programming enthusiast

* Why is software harder to produce when there is more of it?

** Two things I want to focus on

   1. Communication:
      - Code should express the intent of the programmer to other humans
        + In other words: Readability, Expressiveness, Intent

   2. Correctness:
      - Code does what you want and does not break

* Correctness via testing

** The whole purpose of testing is to verify correctness

** Problem: it is horribly ineffective

** As programs grow, their function space becomes enormous

** Tests require manually writing code that verifies all paths and all inputs

   + This is rarely achieved
   + This includes paths and inputs that the programmer cannot foresee
     - (like exceptions, invalid input, timeouts, etc)
     - Even with branch coverage, input coverage is not guaranteed

* Communication is impeded by indirection

** Code is a channel we use to tell other developers what the computer ought to do.

   - More code = more to understand
   - More relevant code in more places = more to store in the reader's head

* Enemies of correctness and communication

  - Unpredictable state mutation
  - Verbosity
  - Leaky abstractions

** The goal: reduce verbosity, control state, provide well defined abstractions

* What if I told you that you could have all this for free?

** You guessed it, functional programming!

* So what is functional programming?

** Core principles:

   - Evaluation of expressions instead of executing statements
   - Preferring pure functions - functions that - given the same input - will always return the same output
   - Emphasizing immutability and returning new - but updated - values over mutating shared state
   - Of course, first class functions (functions are values)

     Most functional programs boil down to:
     f(g(h(x)))

* Many flavors

  A spectrum:

  Purity, Strictness                                 Impurity, Dynamic
  <-------------------------------------------------------------->
  Haskell     OCaml,F#       Scala        Clojure      JavaScript

  - You likely can, if you don't already, do some functional programming everyday

* Declarative and definitional (as opposed to imperative)

  - Instead of providing a set of steps to achieve a goal (imperative)
    you define and (often) let the computer implement the solution
  - No sense of time or order

    #+begin_src js
      // Like a recipe
      function imperativeFactorial(n) {
          var result = 1;
          if (n <= 1) {
              return result;
          }

          while (n >= 1) {
              result *= n;
              --n;
          }

          return result;
      }

      // Everything is an expression!
      function declarativeFactorial(n) {
          if (n >= 1) {
              return 1;
          } else {
              return n * declarativeFactorial(n - 1);
          }
      }
    #+end_src

* Immutability

  - No name (variable) shall ever mean two different things
  - Again, no sense of time or order

#+begin_src haskell
  x = 5

  -- Compile error!
  x = 6

  -- Fresh list - no mutation!
  lowerCaseAll [] = []
  lowerCaseAll (char:chars) = toLower char : lowerCaseAll chars

  -- No worries about the state of the important objects
  -- We can pass around db's, accounts, anything
  updateAccount database account newInfo = update database account newInfo
#+end_src


* First Class Functions

  - functions can be things too!

#+begin_src js
  // Functions as arguments
  [1, 2, 3, 4, 5]
      .map(x => x + 1)
      .filter(x => x < 5)
      .reduce((x, y) => x + y, 0)

  // Return a function from a function
  const f = x => y => z => x + y * z

  // No builder pattern necessary!
  const updateAccount = database => account => newInfo => update(database, account, newInfo)
#+end_src

* There is a lot to functional programming    
  
** I urge you to learn more at your local meetup
   (7-9 every monday!)

* But John!

** How does this relate to correctness and communication?
   
* Pain Point: Refactoring Code 
  
** Refactoring takes a lot of thought and you can break things!

  - need a complete understanding of ALL your code to change a small piece
    + leads to unnecessary cognitive load
  - refactoring can lead to breakage
    + sometimes this means that refactoring never happens
    + this leads to the WTF moments we experience frequently

    #+begin_src java
      // If I want to refactor the AccountManager I have to understand what the delegate and repository do!
      // And no, descriptive names do not help!
      public class AccountManager {

          private AccountDelegate delegate;
          private AccountRepository repository;

          ...

          public AccountStatus signIn(HttpServletRequest request) {
              Account account = repository.retrieveAccount(request.getAttribute("accountId"));

              delegate.signIn(request, account);
              return account.getStatus();
          }
      }
    #+end_src

* Functional Approach: Strong types and immutability

  - With functional type systems, easily communicate (all) of the states you need
  - Immutability means there will not be a nullary, void function
  - I'm not even going to attempt to write this in anything else, because it would take 100 lines

    #+begin_src haskell
      newtype Level = Int


      data Message = Set Level | Reset


      -- Writing a new message will result in compiler errors or warnings
      setLevel :: Message -> Level -> Level
      setLevel message level = case message of
        Reset        -> 1

        Set newLevel -> case level of
          0 -> 1

          _ -> newLevel + 30
    #+end_src

* Pain Point: Procedural and OO code is verbose 
  
** Each line of code is a liability!

  - How many times have you done the following this week? month? lifetime?
  - Creating a whole new class or object simply to pass behavior around

    #+begin_src java
      public class MyController {

          // I have to create both of these classes just to use the functions isValid and handle!
          // Don't even try to tell me that anonymous inner classes help!
          private MyHandler handler;
          private MyValidator validator;

          public MyController(MyHandler handler) {
              this.handler = handler;
          }

          public ResponseObject processMyRoute(HttpServletRequest request) {
              if (validator.isValid(request.getAttribute("myForm"))) {
                  return handler.handle(model, request);
              } else {
                  return null;
              }
          }
      }
    #+end_src

* Functional Approach

** First class functions, well founded abstraction and syntax sugar

  - syntax can be used to replace particularly verbose code
  - well founded abstractions mean using an interface does not require reading a definition
  - first class functions allow for behavior needed at call site to be defined at call site
    
#+begin_src js
  const myRoute = ({ body: { myForm } }) =>
      validate(myForm)
         .map(_ => { message: "excellent form, sir!" })
         .fold(response => response, { message: "poor form, old chap" })
#+end_src


* If you are interested!

  - Professor Frisby's Mostly Adequate Guide
      to Functional Programming
  - Haskell from First Principles
  - Functional Programming through Lambda Calculus

** Come to the Orange Combinator!
    We would love to have you!
